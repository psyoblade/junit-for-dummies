/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package me.suhyuk.junit;

import org.junit.jupiter.api.*;

import java.time.Duration;
import java.util.function.Supplier;

import static org.assertj.core.api.Assertions.assertThat;
import static org.junit.jupiter.api.Assertions.*;

@DisplayNameGeneration(DisplayNameGenerator.ReplaceUnderscores.class) // Underscore 를 빈 공백으로 치환
class StudyTest {
    @BeforeAll
    static void setUp() { // 반환값이 없는 static 함수로 생성되어야만 합니다
        System.out.println("@BeforeAll");
    }

    @AfterAll
    static void tearDown() {
        System.out.println("@AfterAll");
    }

    @BeforeEach
    void beforeEach() {
        System.out.println("@BeforeEach");
    }

    @AfterEach
    void afterEach() {
        System.out.println("@AfterEach");
    }

    /**
     * https://github.com/Coding/emoji-java
     */
    @Test @DisplayName("인사 함수 \uD83C\uDF89") void appHasAGreeting() {
        Study classUnderTest = Study.builder().build();
        assertNotNull(classUnderTest);
    }

    @Test void test_under_score_name() {
        assertTrue(true);
    }

    @Test @Disabled void disabled() {
        assertTrue(true);
    }

    @Test @DisplayName("스터디 객체 상태 확인") void testNormalStudy() {
        Study study = Study.builder().studyStatus(StudyStatus.DRAFT).limit(10).build();
        assertNotNull(study);
        assertTrue(StudyStatus.DRAFT == study.getStudyStatus());
        // 메시지가 단순한 경우에는 그냥 String 으로 넘겨도 무방하지만
        assertEquals(StudyStatus.DRAFT, study.getStudyStatus(), "스터디를 처음 만들면 상태값이 DRAFT 입니다");
        // Java8 Supplier<String> 을 받기 때문에 에러 메시지를 만드는 방법이 복잡하다면, Supplier 를 통해 넘기면, 메시지가 필요한 시점에 get 함수가 호출됩니다
        assertEquals(StudyStatus.DRAFT, study.getStudyStatus(), new Supplier<String>() {
            @Override
            public String get() {
                return "스터디를 처음" + " 만들면 상태값이 " + StudyStatus.DRAFT + " 입니다";
            }
        });
        // 위의 Supplier 구현 대신에 lambda 식을 사용할 수 있습니다
        assertEquals(StudyStatus.DRAFT, study.getStudyStatus(), () -> "스터디를 처음 만들면 상태값이 DRAFT 입니다");
        assertTrue(study.getLimit() > 0, "스터디 최대 참석 가능 인원은 0보다 커야 합니다");
    }

    @Test @DisplayName("스터디 객체 오류") void testAssertAll() {
        Study study = Study.builder().studyStatus(StudyStatus.STARTED).limit(-10).build();
        assertAll(
            () -> assertNotNull(study),
            () -> assertEquals(StudyStatus.DRAFT, study.getStudyStatus()),
            () -> assertEquals(study.getLimit() > 0, "스터디 참여 인원은 0보다 커야 합니다")
        );
    }

    @Test @DisplayName("스터디 예외 확인") void testThrowable() {
        Study.StudyBuilder studyBuilder = Study.builder().studyStatus(StudyStatus.STARTED).limit(101);
        IllegalArgumentException iae = assertThrows(IllegalArgumentException.class, () -> studyBuilder.build());
        assertEquals(Study.ERR_LIMIT, iae.getMessage());
    }

    // TODO 스프링 Transaction 경우 ThreadLocal 을 사용하기 때문에, 외부 공유가 불가능한 경우가 있으므로 예상치 못한 상황이 발생할 수 있습니다
    @Test @DisplayName("스터디 타임아웃") void testTimeout() throws InterruptedException {
        Study study = Study.builder().studyStatus(StudyStatus.DRAFT).limit(10).build();
        assertTimeout(Duration.ofMillis(100), () -> study.sleep(50));
        assertTimeoutPreemptively(Duration.ofMillis(100), () -> study.sleep(5000));
    }

    @Test @DisplayName("다른 방식으로 검증") void testMatcher() {
        Study study = Study.builder().studyStatus(StudyStatus.DRAFT).limit(10).build();
        assertThat(study.getLimit()).isGreaterThan(0);
    }

}
